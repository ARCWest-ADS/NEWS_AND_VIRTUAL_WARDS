
program sumtable
	syntax varlist(min=1 max=2), vartype(name) [vartext(string) dp1(real 0) dp2(real 1) condvar(name) condval(real 1) brackets first last exportname(string) ]

quietly {
	
	*save current dataset to be read back in at the end of each run
	*capture rename temp temp1234
	
	preserve
	
	save "currentds1234", replace
	
	*set up empty dataset with no rows
	if "`first'" !="" {
		if `"`vartype'"'=="headerrow" {
			gen treat1234=`1'
			drop if treat1234==.
			gen treat5678="`1'"
			capture replace treat5678=subinstr(treat5678,",","",.)
			global treat5678_2=treat5678			
			capture decode $treat5678_2, gen(stat1_grp)
			capture gen stat1_grp=`1'
			}
		
		if `"`vartype'"'!="headerrow" {
			gen treat1234=`2'
			drop if treat1234==.
			gen treat5678="`2'"	
			capture replace treat5678=subinstr(treat5678,",","",.)
			global treat5678_2=treat5678			
			capture decode $treat5678_2, gen(stat1_grp)
			capture gen stat1_grp=`2'
		}
		
		quietly sum stat1_grp
		global string=r(min)
		capture tostring stat1_grp, replace
		if $string!=. {
			replace stat1_grp="Group "+ stat1_grp 
		}

		gen stat1_all="Overall"
		gen temp___=1 if treat1234!=.
		bysort treat1234: egen stat2_grp=total(temp___)
		egen stat2_all=total(temp___)
		tostring stat2_grp stat2_all, replace
		replace stat2_grp="n="+stat2_grp
		replace stat2_all="n="+stat2_all
		gen label="Group labels"
		keep treat1234 stat1_grp stat1_all stat2_grp stat2_all label
		duplicates drop
		reshape wide stat1_grp stat2_grp, i(label) j(treat1234)		
		save "dummy1234", replace
		use "currentds1234", clear

	}
	
	*header row
	if `"`vartype'"'=="headerrow" {
		gen label="`vartext'"
		keep if _n==1
		keep label 
		*appending dataset to dummy dataset	and replacing
		append using "dummy1234"
		save "dummy1234", replace
	}
	
	else {
	
	* generating new variable for group variable
	gen treat1234=`2'
	
	* generating new variable for expected values
		if "`condvar'" != "" {
			gen totexp1234=1 if `condvar'==`condval' 
			}
		else {
			gen totexp1234=1 if treat1234 !=.
			}
		


	*dropping out entries with missing group variable
		drop if treat1234==. | totexp1234==.
		
		*sorting out string and numeric categorical variables	
		quietly sum `1'
		global catstring=r(min)
		if $catstring==. & (`"`vartype'"'=="categorical" | `"`vartype'"'=="categorical2") {
			encode `1', gen(`1'2)
			rename `1' `1'_str
			rename `1'2 `1'
		}
		if $catstring!=. & (`"`vartype'"'=="categorical" | `"`vartype'"'=="categorical2") {
			capture decode `1', gen(`1'_str)
			capture tostring `1', gen(`1'_str)
		}	
	
		*generating variable and descriptive text 
		gen label="`vartext'"
		local templabel: variable label `1'
		replace label="`templabel'" if label==""
		local drop templabel
		replace label="`1'" if label==""
		gen level=.
		
		*generating count of missing values in each treatment group and overall
		gen temp1234=1 if `1'==.
		bysort treat1234: egen double miss_grp=total(temp1234)
		egen double miss_all=total(temp1234)
		drop temp1234
	
		**if variable is binary:
		if (`"`vartype'"' == "binary" | `"`vartype'"' == "binary2") { 
			gen levellab=""	
			gen sumtype="(n, %)"
			*generating overall count variable by treatment and overall
			gen temp1234=1 if `1'!=.
			bysort treat1234: egen double tot_grp=total(temp1234) 
			egen double tot_all=total(temp1234)
			drop temp1234
			*generating first variable to identify one patient for each treatment group
			bysort treat1234: gen first=1 if _n==1
			*generating n and % variables for each treatment group and overall
			bysort treat1234: egen double stat1_grp=total(`1')
			bysort treat1234: egen double stat2_grp=mean(100*`1')
			egen double stat1_all=total(`1')
			egen double stat2_all=mean(100*`1')
		}
	
		**if variable is continuous and normally distributed
		else if `"`vartype'"' == "contmean" {
			gen levellab=""	
			gen sumtype="(mean, SD)"
			gen tot_grp=.
			gen tot_all=.
			*generating first variable to identify one patient for each treatment
			bysort treat1234: gen first=1 if _n==1
			*generating mean and SD variables for each treatment and overall
			bysort treat1234: egen double stat1_grp=mean(`1')
			bysort treat1234: egen double stat2_grp=sd(`1')
			egen double stat1_all=mean(`1')
			egen double stat2_all=sd(`1')
		}
	
		**if variable is continuous and not normally distributed
		else if `"`vartype'"' == "contmed" {
			gen levellab=""	
			gen sumtype="(median, IQR)"
			gen tot_grp=.
			gen tot_all=.
			*generating first variable to identify a patient for each treatment
			bysort treat1234: gen first=1 if _n==1
			*generating median and IQR variables for each treatment and overall
			bysort treat1234: egen double stat1_grp=median(`1')
			bysort treat1234: egen temp1__=pctile(`1'), p(25) 
			bysort treat1234: egen temp2__=pctile(`1'), p(75) 
			tostring stat1_grp, format(%12.`dp1'f) replace force
			tostring temp1__ temp2__, format(%12.`dp2'f) replace force
			bysort treat1234: gen stat2_grp="(" + temp1__ + ", " + temp2__ + ")"
			drop temp1__ temp2__
			egen double stat1_all=median(`1')
			egen temp1__=pctile(`1'), p(25) 
			egen temp2__=pctile(`1'), p(75) 
			tostring stat1_all, format(%12.`dp1'f) replace force
			tostring temp1__ temp2__, format(%12.`dp2'f) replace force
			gen stat2_all="(" + temp1__ + ", " + temp2__ + ")"
			drop temp1__ temp2__
		}

		
		**if variable is continuous and not normally distributed and range is required
		else if `"`vartype'"' == "contrange" {
			gen levellab=""	
			gen sumtype="(median, range)"
			gen tot_grp=.
			gen tot_all=.
			*generating first variable to identify a patient for each treatment
			bysort treat1234: gen first=1 if _n==1
			*generating median and IQR variables for each treatment and overall
			bysort treat1234: egen double stat1_grp=median(`1')
			bysort treat1234: egen temp1__=min(`1')
			bysort treat1234: egen temp2__=max(`1')
			tostring stat1_grp, format(%12.`dp1'f) replace force
			tostring temp1__ temp2__, format(%12.`dp2'f) replace force
			bysort treat1234: gen stat2_grp="(" + temp1__ + ", " + temp2__ + ")"
			drop temp1__ temp2__
			egen double stat1_all=median(`1')
			egen temp1__=min(`1')
			egen temp2__=max(`1')
			tostring stat1_all, format(%12.`dp1'f) replace force
			tostring temp1__ temp2__, format(%12.`dp2'f) replace force
			gen stat2_all="(" + temp1__ + ", " + temp2__ + ")"
			drop temp1__ temp2__
		}
		
		**if variable is continuous and geometric means and 95% CIs are required
		else if `"`vartype'"' == "contgeo" {
			gen levellab=""	
			gen sumtype="(geometric mean, 95% CI)"
			gen tot_grp=.
			gen tot_all=.
			*generating first variable to identify a patient for each treatment
			bysort treat1234: gen first=1 if _n==1
			*generating median and IQR variables for each treatment and overall
			bysort treat1234: egen double temp0__=mean(ln(`1'))
			gen stat1_grp=exp(temp0__)
			bysort treat1234: egen temp1__=sd(ln(`1'))
			bysort treat1234: egen temp2__=count(ln(`1'))
			gen temp3__=temp0__-(1.96*(temp1__/sqrt(temp2__)))
			gen temp4__=temp0__+(1.96*(temp1__/sqrt(temp2__)))
			gen temp5__=exp(temp3__)
			gen temp6__=exp(temp4__)
			tostring stat1_grp, format(%12.`dp1'f) replace force
			tostring temp5__ temp6__, format(%12.`dp2'f) replace force
			bysort treat1234: gen stat2_grp=temp5__ + " to " + temp6__
			drop temp0__ temp1__ temp2__ temp3__ temp4__ temp5__ temp6__
			egen double temp0__=mean(ln(`1'))
			gen stat1_all=exp(temp0__)
			egen temp1__=sd(ln(`1'))
			egen temp2__=count(ln(`1'))
			gen temp3__=temp0__-(1.96*(temp1__/sqrt(temp2__)))
			gen temp4__=temp0__+(1.96*(temp1__/sqrt(temp2__)))
			gen temp5__=exp(temp3__)
			gen temp6__=exp(temp4__)
			tostring stat1_all, format(%12.`dp1'f) replace force
			tostring temp5__ temp6__, format(%12.`dp2'f) replace force
			gen stat2_all=temp5__ + " to " + temp6__
			drop temp0__ temp1__ temp2__ temp3__ temp4__ temp5__ temp6__
		}
		

		**if variable is continuous and geometric means and antilog of =/- 1SD on the log scale are required
		else if `"`vartype'"' == "contgeo2" {
			gen levellab=""	
			gen sumtype="(geometric mean, +/- 1SD)"
			gen tot_grp=.
			gen tot_all=.
			*generating first variable to identify a patient for each treatment
			bysort treat1234: gen first=1 if _n==1
			*generating median and IQR variables for each treatment and overall
			bysort treat1234: egen double temp0__=mean(ln(`1'))
			gen stat1_grp=exp(temp0__)
			bysort treat1234: egen temp1__=sd(ln(`1'))
			gen temp2__=temp0__-temp1__
			gen temp3__=temp0__+temp1__
			gen temp4__=exp(temp2__)
			gen temp5__=exp(temp3__)
			tostring stat1_grp, format(%12.`dp1'f) replace force
			tostring temp4__ temp5__, format(%12.`dp2'f) replace force
			bysort treat1234: gen stat2_grp=temp4__ + " to " + temp5__
			drop temp0__ temp1__ temp2__ temp3__ temp4__ temp5__ 
			egen double temp0__=mean(ln(`1'))
			gen stat1_all=exp(temp0__)
			egen temp1__=sd(ln(`1'))
			gen temp2__=temp0__-temp1__
			gen temp3__=temp0__+temp1__
			gen temp4__=exp(temp2__)
			gen temp5__=exp(temp3__)
			tostring stat1_all, format(%12.`dp1'f) replace force
			tostring temp4__ temp5__, format(%12.`dp2'f) replace force
			gen stat2_all=temp4__ + " to " + temp5__
			drop temp0__ temp1__ temp2__ temp3__ temp4__ temp5__ 
		}
		
		
		**if variable is categorical
		else if (`"`vartype'"' == "categorical" | `"`vartype'"' == "categorical2") {
			gen levellab=`1'_str
			replace level=`1'
			gen sumtype="(n, %)"
			*generating overall count variable	
			gen temp1234=1 if `1'!=.
			bysort treat1234: egen double tot_grp=total(temp1234) 
			egen double tot_all=total(temp1234)
			*generating first variable to identify a patient in each category/level for each treatment
			bysort treat1234 `1': gen first=1 if _n==1 & `1'!=.
			*generating n and % variables for each treatment and overall for each level
			bysort treat1234 `1': egen double stat1_grp=total(temp1234)
			bysort treat1234 `1': gen stat2_grp=(stat1_grp*100)/tot_grp
			bysort `1': egen double stat1_all=total(temp1234) 
			gen stat2_all=(stat1_all*100)/tot_all
			drop temp1234
		}	
	
		**if variable is number of events, one row per patient
		else if `"`vartype'"' == "events" { 
			gen levellab=""	
			gen sumtype="(events/patients, %)"
			*generating overall count variable by treatment and overall
			gen temp1234=1 if `1'!=. & `1'!=0
			replace temp1234=0 if `1'==0
			bysort treat1234: egen double tot_grp=total(temp1234) 
			egen double tot_all=total(temp1234)
			*generating first variable to identify one patient for each treatment group
			bysort treat1234: gen first=1 if _n==1
			*generating n and % variables for each treatment group and overall
			bysort treat1234: egen double stat1_grp=total(`1')
			bysort treat1234: egen double stat2_grp=mean(100*temp1234)
			egen double stat1_all=total(`1')
			egen double stat2_all=mean(100*temp1234)
			drop temp1234
		}
		
		
		*only keeping relevant variables
		keep if first==1
		keep label level levellab stat1_grp stat2_grp ///
			stat1_all stat2_all miss_grp miss_all tot_grp tot_all treat1234 sumtype
		*converting numeric variables to strings
		tostring tot* miss*, format(%12.0f) replace force
		tostring stat1*, format(%12.`dp1'f) replace force
		tostring stat2*, format(%12.`dp2'f) replace force

		**if variable is binary
		if `"`vartype'"' == "binary" { 
			*adding totals to counts 
			foreach x in grp all {
				replace stat1_`x'=stat1_`x' + "/" + tot_`x'
			}
			*adding percent sign to percent variables
			foreach x in stat2_grp stat2_all {
				replace `x'=`x' + "%"
			}
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="0/0"	
			replace stat2_grp="" if stat2_grp==".%"
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp tot_grp, i(temp1234) j(treat1234)
			drop temp1234
		}
	
		**if variable is binary (and no denominators required)
		if `"`vartype'"' == "binary2" { 
			*adding percent sign to percent variables
			foreach x in stat2_grp stat2_all {
				replace `x'=`x' + "%"
			}
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="0"	
			replace stat2_grp="" if stat2_grp==".%"
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp tot_grp, i(temp1234) j(treat1234)
			drop temp1234
		}
		
		
		**if variable is continuous and normally distributed
		else if `"`vartype'"' == "contmean"  {
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="."
			replace stat2_grp="" if stat2_grp=="."
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp, i(temp1234) j(treat1234)	
			drop temp1234
		}
	
		**if variable is continuous and not normally distributed
		else if `"`vartype'"' == "contmed" {
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="."
			replace stat2_grp="" if stat2_grp=="(., .)"
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp, i(temp1234) j(treat1234)
			drop temp1234
		}

		**if variable is continuous and not normally distributed and range is required
		else if `"`vartype'"' == "contrange" {
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="."
			replace stat2_grp="" if stat2_grp=="(., .)"
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp, i(temp1234) j(treat1234)
			drop temp1234
		}
		
		**if variable is continuous and not normally distributed and range is required
		else if `"`vartype'"' == "contgeo" | `"`vartype'"' == "contgeo2" {
			*setting zero values to blank
			replace stat1_grp="" if stat1_grp=="."
			replace stat2_grp="" if stat2_grp==". to ."
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp, i(temp1234) j(treat1234)
			drop temp1234
		}
		
		**if variable is categorical
		else if `"`vartype'"' == "categorical" {
			*adding percent sign to percent variables
			foreach x in stat2_grp stat2_all {
				replace `x'=`x' + "%"
			}
			*adding totals to counts 
			foreach x in grp all {
				replace stat1_`x'=stat1_`x' + "/" + tot_`x'
			}
			*reshaping to make dataset just one row	per category/level
			gen temp1234=10000 + level
			reshape wide stat1_grp stat2_grp tot_grp miss_grp, i(temp1234) j(treat1234)
			drop temp1234
			*replacing empty variables	
			forvalues x=0(1)1000 {
				capture gsort -tot_grp`x'
				capture replace miss_grp`x'=miss_grp`x'[_n-1] if miss_grp`x'==""
				capture replace tot_grp`x'=tot_grp`x'[_n-1] if tot_grp`x'==""
				capture replace stat1_grp`x'="0/" + tot_grp`x' if stat1_grp`x'==""
				capture gen temp1234=1 if stat2_grp`x'==""
				capture replace stat2_grp`x'="0" if temp1234==1
				capture replace stat2_grp`x'=stat2_grp`x'+"." if temp1234==1 & `dp2'>=1
				capture forvalues i=1(1)`dp2' {
					replace stat2_grp`x'=stat2_grp`x'+"0" if temp1234==1
				}
				capture replace stat2_grp`x'=stat2_grp`x'+"%" if temp1234==1
				capture drop temp1234
			}
		sort level
		}	
		
		
		**if variable is categorical (and no denominators required)
		else if `"`vartype'"' == "categorical2" {
			*adding percent sign to percent variables
			foreach x in stat2_grp stat2_all {
				replace `x'=`x' + "%"
			}
			*reshaping to make dataset just one row	per category/level
			gen temp1234=10000 + level
			reshape wide stat1_grp stat2_grp tot_grp miss_grp, i(temp1234) j(treat1234)
			drop temp1234
			*replacing empty variables	
			forvalues x=0(1)1000 {
				capture gsort -tot_grp`x'
				capture replace miss_grp`x'=miss_grp`x'[_n-1] if miss_grp`x'==""
				capture replace tot_grp`x'=tot_grp`x'[_n-1] if tot_grp`x'==""
				capture replace stat1_grp`x'="0" if stat1_grp`x'==""
				capture gen temp1234=1 if stat2_grp`x'==""
				capture replace stat2_grp`x'="0" if temp1234==1
				capture replace stat2_grp`x'=stat2_grp`x'+"." if temp1234==1 & `dp2'>=1
				capture forvalues i=1(1)`dp2' {
					replace stat2_grp`x'=stat2_grp`x'+"0" if temp1234==1
				}
				capture replace stat2_grp`x'=stat2_grp`x'+"%" if temp1234==1
				capture drop temp1234
			}
		sort level
		}	
		
		
		**if variable is number of events, one row per patient
		else if `"`vartype'"' == "events" { 
			*adding totals to counts 
			foreach x in grp all {
				replace stat1_`x'=stat1_`x' + "/" + tot_`x'
			}
			*adding percent sign to percent variables
			foreach x in stat2_grp stat2_all {
				replace `x'=`x' + "%"
			}
			*setting zero values to blank
			replace stat1_grp="" if stat2_grp==".%"	
			replace stat2_grp="" if stat2_grp==".%"
			*reshaping to make dataset just one row	
			gen temp1234=1
			reshape wide stat1_grp stat2_grp miss_grp tot_grp, i(temp1234) j(treat1234)
			drop temp1234
		}	
		
		
		* Adding brackets around the second statistics if the 'brackets' option is stated
		if "`brackets'" !="" {
			forvalues x=0(1)1000 {
				capture replace stat2_grp`x'="(" + stat2_grp`x' + ")" if stat2_grp`x'!=""
			}
			replace stat2_all="(" + stat2_all + ")" if stat2_all!=""
		}
		
		
		*dropping total counts
		drop tot_*

		*appending dataset to dummy dataset, saving and replacing
		append using "dummy1234"
		save "dummy1234", replace	

	}

	**generating excel output table of all results in excel
	*sorting
	if "`last'"!="" {
		gen varnum=_n if label[_n]!=label[_n-1]
		replace varnum=varnum[_n-1] if varnum==.
		gen varnum2=-varnum
		sort varnum2 level
		bysort varnum2 label: replace label="" if _n!=1
		bysort varnum2 sumtype: replace sumtype="" if _n!=1
		bysort varnum2 miss_all: replace miss_all="" if _n!=1
		forvalues x=0(1)1000 {
			capture bysort varnum2 miss_grp`x': replace miss_grp`x'="" if _n!=1
		}	

		*ordering
		forvalues x=1000(-1)0 {
			capture order label sumtype level levellab stat1_grp`x' stat2_grp`x' miss_grp`x'
		}
		order stat1_all stat2_all miss_grp* miss_all, last
		
		* dropping unused variables
		drop varnum varnum2 level
		quietly count if levellab!=""
		if `r(N)'==0 drop levellab
	
		*generating missing count footnote
		gen rowcount=_n
		tostring rowcount, gen(rowcount2)
		save "prefootnote1234", replace

		split stat1_all, parse("/") gen(splitup)
				
		gen toprow=1 if label=="Group labels" & miss_all==""
		gen header=1 if stat1_all=="" & stat2_all==""
		gen nomiss=1 if miss_all=="0"
		gen binary=1 if strpos(stat1_all, "/") & sumtype=="(n, %)"
		gen repeatcat=1 if label==""
		keep rowcount rowcount2 miss_grp* miss_all toprow header nomiss binary repeatcat

		
		gen missing= rowcount2 + "*Data missing for " + miss_all + " patients " + "("
		forvalues x=0(1)1000 {
			capture replace missing = missing + miss_grp`x'+ ", "
		}
			
		replace missing = missing + ")"
		replace missing=subinstr(missing,", )","). ", .)
	
		drop if toprow==1 | header==1 | binary==1 | nomiss==1 | repeatcat==1
		keep rowcount missing
	
		gen temp3=1
		capture reshape wide missing, i(temp3) j(rowcount)
		capture egen rowcount=concat(missing*)
		capture keep rowcount
		capture tostring rowcount, replace
		save "missingrow1234", replace
	
		use "prefootnote1234", clear
		drop rowcount
		rename rowcount2 rowcount
		append using "missingrow1234"

		*exporting to Excel
		if "`exportname'" != "" {
				export excel using "`exportname'.xls", replace firstrow(variables)
				}
				else {
				export excel using "summarydatasetexcel.xls", replace firstrow(variables)
				}
			
		erase "dummy1234.dta"
		erase "missingrow1234.dta"
		erase "prefootnote1234.dta"
	}

	restore
	
	*capture rename temp1234 temp
	erase "currentds1234.dta"	

}

end


	
